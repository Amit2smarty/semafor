This is a README for training on the FrameNet 1.5 full text annotations
Dipanjan Das 
dipanjan@cs.cmu.edu
2/18/2012
=======================================================================

Training models for frame-semantic parsing with SEMAFOR is still a very laborious and 
clunky set of steps. Your kind patience is required to train the models :-)

0) Run svn checkout https://semafor-semantic-parser.googlecode.com/svn/trunk/ semafor-semantic-parser. Compile necessary files as you go.


1) The first step is to create some data structures which are used to train and test the frame identification and argument identification models (please refer to our NAACL 2010 paper to understand these two steps). The first step is to create two maps -- I name these framenet.original.map and framenet.frame.element.map

   i) The first map is of type THashMap<String, THashSet<String>>. It maps a frame to a set of disambiguated predicates 
      (words along with part of speech tags, but in the style of FrameNet). 
   ii) The second map is of type THashMap<String,THashSet<String>>, which maps each frame to a set of frame element names. 
       In other words, this data structure is necessary for the argument identification model to know what 
       the frame elements are for each frame.
 
My versions of these two maps are present in this directory (these are just serialized Java objects). Use the semafor-deps.jar file in lib/ directory of the googlecode repository to get the right version of GNU trove, and read (deserialize) these two maps. After that print the keys, and the corresponding values to see exactly what is stored in these maps. After that, you will need to create your own versions of these two maps for your domain, in exactly the same format as these maps.

If you want existing code in SEMAFOR to create these maps, you could use the method writeSerializedObject(Object object, String outFile) in edu/cmu/cs/lti/ark/util/SerializedObjects.java to write serialize those maps. So creating your own maps will be easy. You could also read the maps using that class.



2) The next step creates some more data structures used for the training and inference procedure. You will find a class called: edu/cmu/cs/lti/ark/fn/identification/RequiredDataCreation.java. Compile it, then run the script:

./training/createRequiredData.sh



3) This step corresponds to training the frame identification model. I will be using the flags declared above.

  i) 
  # step 1: alphabet creation. Run the script:
  ./training/trainFrameIdentificationModel.sh
  # This takes ~75 minutes on my 2.2 GHz Intel Core i7 4 core macbook pro (sam)

  ii)
  # step 2: alphabet combination. Run the script:
  ./training/combineAlphabets.sh
  # Takes ~3 seconds

  iii)
  # step 3: creating feature events for each datapoint. Run the script:
  ./training/createFeatureEvents.sh
  # Takes ~50 minutes

  iv) After the above step is done in the ${datadir}/events directory, you will find tons of the serialized objects, which are the feature vectors for
      each data point. After this events creation is done, you can run training by running:
  # step 4: training the frame identification model. Run the script:
  ./training/trainBatch.sh
  # takes ~4 hours

  The training procedure will run for a long period of time. Line search in L-BFGS may fail at the end, but that does not mean training failed. In models_0.0, there will be models produced every few iterations. If line search failed, take the last model.

  v)
  # step 5: convert the alphabet file. Run the script:
  ./training/convertAlphabetFile.sh
  # takes ~3 seconds


We do not use the format of the model file produced by the above procedure, but convert it to a more usable version. To do that,
use edu.cmu.cs.lti.ark.fn.identification.ConvertAlphabetFile to convert the produced models to the new format. 
The class takes three arguments: the alphabet file path, the model file path, and the output model file path.


4) This step corresponds to the training the argument identification model. 


  mkdir ${datadir}/scan

  # step 1: Alphabet Creation

   $jhome/java -classpath ${classpath} -Xms4000m -Xmx4000m edu.cmu.cs.lti.ark.fn.parsing.CreateAlphabet \
   ${datadir}/cv.train.sentences.frame.elements \
   ${datadir}/cv.train.sentences.all.lemma.tags \
   ${datadir}/scan/cv.train.events.bin \
   ${datadir}/scan/parser.conf.unlabeled \
   ${datadir}/scan/cv.train.sentences.frame.elements.spans \
   true \
   false \
   1 \
   null \
   ${datadir}/framenet.frame.element.map


  # step 2: Caching Feature Vectors
  $jhome/java -classpath ${classpath} -Xms4000m -Xmx4000m edu.cmu.cs.lti.ark.fn.parsing.FrameFeaturesCache \
  eventsfile:${datadir}/scan/cv.train.events.bin \
  spansfile:${datadir}/scan/cv.train.sentences.frame.elements.spans \
  train-framefile:${datadir}/cv.train.sentences.frame.elements \
  localfeaturescache:${datadir}/scan/featurecache.jobj

  # step 3: training
  $jhome/java -classpath ${classpath} -Xms8000m -Xmx8000m edu.cmu.cs.lti.ark.fn.parsing.TrainingBatchMain \
  model:${datadir}/argmodel.dat \ 
  alphabetfile:${datadir}/scan/parser.conf.unlabeled \
  localfeaturescache:${datadir}/scan/featurecache.jobj \
  train-framefile:${datadir}/cv.train.sentences.frame.elements \
  regularization:reg \
  lambda:0.1 \
  numthreads:4 \
  binaryoverlapfactor:false

You may tune lambda on a development set to get the best results.